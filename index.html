<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>YouBike æ¯å°æ™‚åœ¨ç«™è»Šè¼›æ•¸ï¼ˆå«èª¿åº¦æœ€ä½³è§£ï¼‰</title>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<style>
body { font-family:"Microsoft JhengHei",Arial; margin:20px; }
.section { border:1px solid #ccc; border-radius:8px; padding:12px; margin-bottom:12px; }
label { display:inline-block; width:190px; }
input { padding:6px; margin:4px 0; }
button { padding:6px 10px; margin-top:6px; cursor:pointer; }
small { color:#555; }
canvas { max-height:420px; }

table { border-collapse:collapse; width:100%; margin-top:8px; }
th,td { border:1px solid #ccc; padding:4px 6px; text-align:center; }
.overUp { background:#f8d7da; }
.overDown { background:#dbeafe; }
.kpi { font-weight:700; }
.msg { padding:8px 10px; background:#f6f6f6; border-radius:6px; margin-top:8px; white-space:pre-line; }
</style>
</head>

<body>

<h2>YouBike æ¯å°æ™‚åœ¨ç«™è»Šè¼›æ•¸ï¼ˆå«èª¿åº¦æœ€ä½³è§£ï¼‰</h2>

<div class="section">
  <b>â‘  ä¸Šå‚³ Excelï¼ˆé›™åŒ—é…ç½®ç·šä¸Šç‰ˆ v1.xlsx â†’ æ¯å°æ™‚è®ŠåŒ–ï¼‰</b><br>
  <input type="file" id="fileInput" accept=".xlsx">
  <div class="msg" id="loadMsg" style="display:none;"></div>
</div>

<div class="section">
  <label>å ´ç«™</label>
  <input list="stations" id="station"><br>

  <label>è²¬ä»»å€</label>
  <input id="area" readonly>
  <label>ç¸½è»Šä½</label>
  <input id="capacity" readonly><br>

  <label>5 é»è»Šè¼›æ•¸</label>
  <input type="number" id="init" value="0">
  <small>ï¼ˆæ•´å¤©åœ¨ç«™æ•¸ä»¥æ­¤ç‚ºåŸºæº–ï¼ŒåŠ ä¸Š Excel çš„æ¯å°æ™‚è®ŠåŒ–é‡èˆ‡èª¿åº¦é‡ï¼‰</small><br>

  <label>10â€“15 é»èª¿åº¦æ•¸é‡ï¼ˆå½±éŸ¿ 15â€“23ï¼‰</label>
  <input type="number" id="dispatch15" value="0"><br>

  <label>21â€“24 é»èª¿åº¦æ•¸é‡ï¼ˆå½±éŸ¿ 21â€“23ï¼‰</label>
  <input type="number" id="dispatch21" value="0"><br>

  <button id="btnSolve">ä¸€éµè©¦ç®—æœ€ä½³è§£ï¼ˆå„ªå…ˆèª¿åº¦=0ï¼‰</button>
  <div class="msg" id="solveMsg" style="display:none;"></div>
</div>

<datalist id="stations"></datalist>

<div class="section">
  <canvas id="chart"></canvas>
</div>

<div class="section">
  <h3>é€æ™‚åœ¨ç«™è»Šè¼›æ•¸ï¼ˆå¯¦éš›å€¼ï¼‰</h3>
  <div id="dataTable"></div>
</div>

<script>
let DB = [];
const HOURS = [5, ...Array.from({length:18},(_,i)=>i+6)];
let chart = null;

fileInput.addEventListener("change", loadExcel);
station.addEventListener("change", refresh);
init.addEventListener("input", refresh);
dispatch15.addEventListener("input", refresh);
dispatch21.addEventListener("input", refresh);
btnSolve.addEventListener("click", autoSolve);

function showMsg(el, txt){
  el.style.display = "block";
  el.textContent = txt;
}

function loadExcel(e){
  const file = e.target.files[0];
  if(!file){ return; }

  const reader = new FileReader();
  reader.onload = evt => {
    const wb = XLSX.read(evt.target.result, { type:"array" });
    const ws = wb.Sheets["æ¯å°æ™‚è®ŠåŒ–"];
    if(!ws){ alert("æ‰¾ä¸åˆ°å·¥ä½œè¡¨ï¼šæ¯å°æ™‚è®ŠåŒ–"); return; }

    const rows = XLSX.utils.sheet_to_json(ws);
    DB = rows.map(r => ({
      station: r["å ´ç«™"],
      area: r["è²¬ä»»å€"],
      code: r["ç·¨è™Ÿ"],
      capacity: Number(r["ç¸½è»Šä½æ•¸"]),
      start5: ("5èµ·å§‹è»Šè¼›" in r) ? Number(r["5èµ·å§‹è»Šè¼›"]) : null,
      deltas: Object.fromEntries(Array.from({length:18},(_,i)=>[i+6, Number(r[i+6])]))
    }));

    stations.innerHTML = DB.map(d => `<option value="${d.station}">`).join("");
    showMsg(loadMsg, `Excel è¼‰å…¥å®Œæˆï¼š${DB.length} ç­†å ´ç«™\nè«‹é¸å ´ç«™å¾Œå¯ç›´æ¥è©¦ç®— / èª¿æ•´åƒæ•¸`);
  };
  reader.readAsArrayBuffer(file);
}

// ====== æ ¸å¿ƒï¼šä¾ä½ è¦å‰‡è¨ˆç®—åœ¨ç«™è»Šè¼›æ•¸ ======
function computeActualSeries(rec, base, D15, D21){
  const series = [];
  // 5
  series.push(base);
  for(let h=6; h<=23; h++){
    let v = base + rec.deltas[h];
    if(h >= 15) v += D15;
    if(h >= 21) v += D21;
    series.push(v);
  }
  return series; // index aligns with HOURS
}

// ====== ä¸€éµæ±‚è§£ï¼ˆå„ªå…ˆ D15=D21=0ï¼‰ ======
// æ¢ä»¶ï¼šå°æ‰€æœ‰å°æ™‚ 0 < S(h) < Cï¼›ä¸” 0 < B < C
function boundsForHours(rec, hoursArr){
  const C = rec.capacity;
  let lo = -1e18, hi = 1e18;
  for(const h of hoursArr){
    const delta = (h === 5) ? 0 : rec.deltas[h];
    lo = Math.max(lo, -delta + 1);
    hi = Math.min(hi, C - delta - 1);
  }
  return [Math.trunc(lo), Math.trunc(hi)];
}
function clamp(x, lo, hi){ return x < lo ? lo : (x > hi ? hi : x); }

function chooseB(lo, hi, prefer){
  if(lo > hi) return null;
  if(Number.isFinite(prefer) && lo <= prefer && prefer <= hi) return Math.trunc(prefer);
  return Math.trunc((lo + hi) / 2);
}

function autoSolve(){
  if(DB.length === 0){ alert("è«‹å…ˆä¸Šå‚³ Excel"); return; }
  const rec = DB.find(d => d.station === station.value);
  if(!rec){ alert("è«‹å…ˆé¸æ“‡å ´ç«™"); return; }

  const C = rec.capacity;

  // segment hours
  const H1 = Array.from({length:10},(_,i)=>i+5);   // 5-14
  const H2 = Array.from({length:6},(_,i)=>i+15);   // 15-20
  const H3 = [21,22,23];

  // base constraints from 5-14 (dispatch can't fix)
  const [A1,B1] = boundsForHours(rec, H1);
  let Lbase = Math.max(1, A1);
  let Ubase = Math.min(C-1, B1);
  if(Lbase > Ubase){
    showMsg(solveMsg, `ã€ç„¡è§£ã€‘5â€“14 é»å·²ç„¡æ³•æ»¿è¶³ 0<S<Cï¼ˆèª¿åº¦ä¹Ÿç„¡æ³•ä¿®æ­£ï¼‰`);
    return;
  }

  const [A2,B2] = boundsForHours(rec, H2);
  const [A3,B3] = boundsForHours(rec, H3);

  // 1) priority: D15=0,D21=0
  let L0 = Math.max(Lbase, A2, A3);
  let U0 = Math.min(Ubase, B2, B3);
  if(L0 <= U0){
    const b = chooseB(L0, U0, rec.start5);
    init.value = b;
    dispatch15.value = 0;
    dispatch21.value = 0;
    showMsg(solveMsg, `âœ… æœ€ä½³è§£ï¼ˆèª¿åº¦=0ï¼‰å­˜åœ¨\nå¯è¡Œ 5 é»é…ç½®ç¯„åœï¼š${L0}ï½${U0}\næ¨è–¦ 5 é»é…ç½®ï¼š${b}\nD15=0ã€D21=0`);
    refresh();
    return;
  }

  // 2) minimal dispatch
  // D15 feasible range so that Ibase âˆ© I2(D15) non-empty, where I2(D15)=[A2-D15, B2-D15]
  const rlo = A2 - Ubase;
  const rhi = B2 - Lbase;
  if(rlo > rhi){
    showMsg(solveMsg, `ã€ç„¡è§£ã€‘15â€“20 é»ç„¡æ³•é€é D15 å½¢æˆå¯è¡Œå€é–“ï¼ˆçµæ§‹æ€§å¤±è¡¡ï¼‰`);
    return;
  }

  // enumerate D15 by increasing abs within [rlo,rhi]
  const candD15 = [];
  const maxAbs = Math.max(Math.abs(rlo), Math.abs(rhi));
  for(let k=0; k<=maxAbs; k++){
    const vals = (k===0) ? [0] : [k, -k];
    for(const v of vals){
      if(rlo <= v && v <= rhi) candD15.push(v);
    }
    if(candD15.length > 2000) break;
  }

  let best = null;

  for(const D15 of candD15){
    // I12 = Ibase âˆ© I2(D15)
    const L12 = Math.max(Lbase, A2 - D15);
    const U12 = Math.min(Ubase, B2 - D15);
    if(L12 > U12) continue;

    // feasible Dsum = D15+D21 from segment3 overlap with I12: Dsum in [A3-U12, B3-L12]
    const sumLo = A3 - U12;
    const sumHi = B3 - L12;
    if(sumLo > sumHi) continue;

    // pick Dsum closest to D15 to minimize |D21|
    const Dsum = clamp(D15, sumLo, sumHi);
    const D21 = Dsum - D15;
    const total = Math.abs(D15) + Math.abs(D21);

    // final B range
    const Lfinal = Math.max(L12, A3 - Dsum);
    const Ufinal = Math.min(U12, B3 - Dsum);
    if(Lfinal > Ufinal) continue;

    const b = chooseB(Lfinal, Ufinal, rec.start5);

    const cand = {D15, D21, total, Lfinal, Ufinal, b};
    if(!best || cand.total < best.total || (cand.total === best.total && Math.abs(cand.D15) < Math.abs(best.D15))){
      best = cand;
      if(best.total === 1) break;
    }
  }

  if(!best){
    showMsg(solveMsg, `ã€ç„¡è§£ã€‘å˜—è©¦æœ€å°èª¿åº¦ä»ç„¡æ³•æ»¿è¶³æ•´å¤© 0<S<Cï¼ˆå»ºè­°åˆ—ç‚ºçµæ§‹æ€§å¤±è¡¡ç«™ï¼‰`);
    return;
  }

  init.value = best.b;
  dispatch15.value = best.D15;
  dispatch21.value = best.D21;

  const cls = (best.total <= C) ? "B(éœ€èª¿åº¦)" : "C(é«˜èª¿åº¦éœ€æ±‚)";
  showMsg(solveMsg,
    `âš  æ‰¾ä¸åˆ°èª¿åº¦=0è§£ï¼Œå·²æä¾›æœ€å°èª¿åº¦è§£\né¡åˆ¥ï¼š${cls}\nå¯è¡Œ 5 é»é…ç½®ç¯„åœï¼š${best.Lfinal}ï½${best.Ufinal}\næ¨è–¦ï¼š5é»=${best.b}ã€D15=${best.D15}ã€D21=${best.D21}\næœ€å°èª¿åº¦ç¸½é‡ |D15|+|D21| = ${best.total}`
  );
  refresh();
}

// ====== åœ–è¡¨èˆ‡è¡¨æ ¼ï¼ˆæ²¿ç”¨ä½ ä¸Šæ¬¡å°ˆæ¡ˆï¼šä¸Šé™=è»Šä½ã€ä¸‹é™=-2Ã—è»Šä½ã€0ç·šæ©˜è‰²ã€è¶…é™/ä¸‹é™æ¨™è¨˜èˆ‡æ•¸å€¼é¡¯ç¤ºã€æœ€å¾Œé»æ–‡å­—ä¸å‡ºæ¡†ï¼‰ ======
function refresh(){
  if(DB.length === 0) return;
  const rec = DB.find(d => d.station === station.value);
  if(!rec) return;

  area.value = rec.area;
  capacity.value = rec.capacity;

  const base = Number(init.value);
  if(!Number.isFinite(base)) return;

  const D15 = Number(dispatch15.value) || 0;
  const D21 = Number(dispatch21.value) || 0;

  const upper = rec.capacity;          // ä¸Šé™=è»Šä½
  const lower = -rec.capacity * 2;     // ä¸‹é™=-2Ã—è»Šä½

  const actual = computeActualSeries(rec, base, D15, D21);
  const plot = [];
  const overUp = [];
  const overDown = [];

  for(const v of actual){
    if(v > upper){
      plot.push(upper); overUp.push(v); overDown.push(null);
    }else if(v < lower){
      plot.push(lower); overUp.push(null); overDown.push(v);
    }else{
      plot.push(v); overUp.push(null); overDown.push(null);
    }
  }

  drawChart(plot, overUp, overDown, upper, lower, rec.station);
  drawTable(actual, rec.capacity, upper, lower);
}

function drawChart(plot, overUp, overDown, upper, lower, label){
  if(chart) chart.destroy();

  chart = new Chart(document.getElementById("chart"), {
    type:"line",
    data:{
      labels:HOURS,
      datasets:[
        {
          label: label + " åœ¨ç«™è»Šè¼›æ•¸",
          data: plot,
          borderColor:"green",
          borderWidth:2,
          tension:0.35,
          pointRadius: ctx => (overUp[ctx.dataIndex] || overDown[ctx.dataIndex]) ? 6 : 3,
          pointStyle: ctx => overUp[ctx.dataIndex] ? "triangle" :
                             overDown[ctx.dataIndex] ? "triangle" : "circle",
          rotation: ctx => overDown[ctx.dataIndex] ? 180 : 0
        },
        {
          label:"è»Šä½ä¸Šé™",
          data:HOURS.map(()=>upper),
          borderDash:[6,6],
          borderColor:"red",
          pointRadius:0
        },
        {
          label:"é¡¯ç¤ºä¸‹é™ (-2Ã—)",
          data:HOURS.map(()=>lower),
          borderDash:[6,6],
          borderColor:"red",
          pointRadius:0
        },
        {
          label:"0 åŸºæº–",
          data:HOURS.map(()=>0),
          borderColor:"orange",
          pointRadius:0
        }
      ]
    },
    options:{
      scales:{ y:{ min: lower, max: upper } }
    },
    plugins:[{
      id:"valueLabels",
      afterDatasetsDraw(chart){
        const {ctx, scales:{x,y}} = chart;
        ctx.save();
        ctx.fillStyle = "red";
        ctx.font = "12px Arial";

        plot.forEach((_,i)=>{
          const xPos = x.getPixelForValue(i);
          const isLast = i === HOURS.length - 1;
          const offsetX = isLast ? -30 : 6;

          if(overUp[i] !== null){
            ctx.fillText(overUp[i], xPos + offsetX, y.getPixelForValue(upper) - 6);
          }
          if(overDown[i] !== null){
            ctx.fillText(overDown[i], xPos + offsetX, y.getPixelForValue(lower) + 14);
          }
        });
        ctx.restore();
      }
    }]
  });
}

function drawTable(actual, capacity, upper, lower){
  let html = `
    <table>
      <tr>
        <th>æ™‚é–“</th>
        <th>åœ¨ç«™è»Šè¼›æ•¸ï¼ˆå¯¦éš›ï¼‰</th>
        <th>ç‹€æ…‹</th>
        <th>èˆ‡è»Šä½å·®è·</th>
        <th>é¢¨éšª</th>
      </tr>
  `;

  actual.forEach((v,i)=>{
    let cls="", status="æ­£å¸¸", risk="";
    if(v > upper){ cls="overUp"; status="è¶…éè»Šä½ä¸Šé™"; risk="âš "; }
    else if(v < lower){ cls="overDown"; status="ä½æ–¼é¡¯ç¤ºä¸‹é™"; risk="ğŸ”»"; }

    html += `
      <tr class="${cls}">
        <td>${HOURS[i]}</td>
        <td>${v}</td>
        <td>${status}</td>
        <td>${v - capacity}</td>
        <td>${risk}</td>
      </tr>
    `;
  });

  html += "</table>";
  dataTable.innerHTML = html;
}
</script>

</body>
</html>
